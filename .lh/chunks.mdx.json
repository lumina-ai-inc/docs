{
    "sourceFile": "chunks.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 20,
            "patches": [
                {
                    "date": 1727386436235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1727386465062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,104 +1,5 @@\n ---\n title: Chunks\n ---\n-The ChunkMyDocs API processes documents by analyzing their layout and segmenting them into meaningful chunks suitable for Retrieval-Augmented Generation (RAG) and Large Language Models (LLMs). \n+Chunks are collections of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter.\n \n-![Model Diagram](sample2.png)\n-\n-## Segments vs. Chunks\n-\n-- **Segments**: These are the fundamental building blocks extracted from the document. Each segment represents a specific part of the document, such as a title, section header, paragraph, list item, table, picture, caption, formula, footnote, page header, or footer. Segments are identified using unique identifiers, precise bounding boxes, and their content type.\n-\n-- **Chunks**: Chunks are collections of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter:\n-\n-  - **No Chunking (`target_chunk_length = 0`)**: Each segment is treated as an individual chunk, maintaining a one-to-one relationship and preserving the original document structure without additional grouping.\n-\n-  - **With Chunking (`target_chunk_length > 0`)**: Segments are grouped into chunks up to the defined length, excluding headers and footers to maintain content integrity. For example, with `target_chunk_length = 512`, each chunk can contain up to 512 words.\n-\n-## Segment and Chunk Models\n-\n-### Segment Model\n-\n-The `Segment` model represents individual elements extracted from the document. It includes the following properties:\n-\n-- `segment_id`: Unique identifier for the segment.\n-- `bbox`: Bounding box defining the segment's position on the page.\n-- `page_number`: Integer specifying the page number.\n-- `page_width`, `page_height`: Dimensions of the page.\n-- `content`: Text content of the segment.\n-- `segment_type`: Type of the segment (e.g., Title, Text, Table).\n-- `ocr`: Optional OCR results associated with the segment.\n-- `image`, `html`, `markdown`: Optional representations of the segment's content.\n-\n-### Chunk Model\n-\n-The `Chunk` model represents a collection of segments. It consists of:\n-\n-- `segments`: An array of `Segment` objects.\n-- `chunk_length`: Integer specifying the length of the chunk in words.\n-\n-For detailed schema information, please refer to the API documentation.\n-\n-## Bounding Boxes and DPI\n-\n-Accurate annotation of segments relies on precise bounding boxes, which are determined based on the document's DPI (Dots Per Inch). DPI affects the scaling and positioning of elements within the document:\n-\n-- **Bounding Boxes**: Each segment has a bounding box defined by its top-left and bottom-right coordinates. These coordinates locate the segment within the page, ensuring that annotations and further processing align correctly with the original document layout.\n-\n-- **DPI Considerations**: The DPI setting influences how bounding boxes are calculated. By default, all incoming files are scaled to 150 DPI, and bounding box coordinates are based on this scaling to maintain consistency.\n-\n-## Annotating Segments and Chunks\n-\n-Annotation involves visually highlighting segments within the document to provide clarity and facilitate further analysis. The `annotate.py` script is responsible for drawing bounding boxes around segments:\n-\n-```python\n-import fitz  # PyMuPDF\n-from models import TaskResponse\n-import json\n-\n-def draw_bounding_boxes(pdf_path: str, output_data: TaskResponse, output_path: str):\n-    color_map = {\n-        \"Caption\": (1, 0, 0),\n-        \"Footnote\": (0, 1, 0),\n-        \"Formula\": (0, 0, 1),\n-        \"ListItem\": (1, 1, 0),\n-        \"PageFooter\": (1, 0.5, 0),\n-        \"PageHeader\": (0.5, 0, 0.5),\n-        \"Picture\": (1, 0.75, 0.8),\n-        \"SectionHeader\": (0.6, 0.3, 0),\n-        \"Table\": (0.54, 0, 0),\n-        \"Text\": (0, 0, 0),\n-        \"Title\": (1, 0, 0)\n-    }\n-\n-    pdf_document = fitz.open(pdf_path)\n-\n-    for chunk in output_data.chunks or []:\n-        for seg in chunk.segments:\n-            page = pdf_document[seg.page_number - 1]\n-            rect = fitz.Rect(\n-                seg.bbox.top_left[0],\n-                seg.bbox.top_left[1],\n-                seg.bbox.bottom_right[0],\n-                seg.bbox.bottom_right[1]\n-            )\n-            color = color_map.get(seg.segment_type, (0, 0, 0))\n-            page.draw_rect(rect, color=color, width=1)\n-\n-    pdf_document.save(output_path)\n-    pdf_document.close()\n-```\n-\n-### How It Works\n-\n-1. **Color Mapping**: Each segment type is assigned a specific color for easy differentiation during annotation.\n-2. **Processing Segments**: The script iterates through all chunks and their respective segments, drawing rectangles around each segment based on their bounding box coordinates.\n-\n-By understanding and utilizing segments and chunks effectively, along with accurate bounding box annotations, you can leverage the ChunkMyDocs API to its full potential, enabling robust document analysis and processing workflows.\n-\n-```\n-\n-```\n-\n-\n-![Model Diagram](sample2.png)\n"
                },
                {
                    "date": 1727386505063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n ---\n title: Chunks\n ---\n-Chunks are collections of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter.\n+Chunks are collections of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter. Click [here]() to learn more about how to configure it.\n \n"
                },
                {
                    "date": 1727386517461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n ---\n title: Chunks\n ---\n-Chunks are collections of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter. Click [here]() to learn more about how to configure it.\n+Chunks are collections of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter. Click [here](/Chunking) to learn more about how to configure it.\n \n"
                },
                {
                    "date": 1727386547224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n ---\n title: Chunks\n ---\n-Chunks are collections of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter. Click [here](/Chunking) to learn more about how to configure it.\n \n+The output of a task is a list of chunks. Each chunk is a collection of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter. Click [here](/chunking) to learn more about how to configure it.\n+\n"
                },
                {
                    "date": 1727386574216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,8 @@\n ---\n title: Chunks\n ---\n \n-The output of a task is a list of chunks. Each chunk is a collection of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter. Click [here](/chunking) to learn more about how to configure it.\n+The output of a task is a list of chunks. Each chunk is a collection of one or more segments.\n \n+The grouping of segments into chunks depends on the `target_chunk_length` parameter. Click [here](/chunking) to learn more about how to configure it.\n+\n"
                },
                {
                    "date": 1727386593778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,4 +5,7 @@\n The output of a task is a list of chunks. Each chunk is a collection of one or more segments.\n \n The grouping of segments into chunks depends on the `target_chunk_length` parameter. Click [here](/chunking) to learn more about how to configure it.\n \n+## Chunk Model\n+\n+The `Chunk` model represents a collection of segments. It consists of:\n"
                },
                {
                    "date": 1727386617311,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,4 +8,7 @@\n \n ## Chunk Model\n \n The `Chunk` model represents a collection of segments. It consists of:\n+\n+```json\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727386665160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,4 +9,6 @@\n ## Chunk Model\n \n The `Chunk` model represents a collection of segments. It consists of:\n \n+```json\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727386676107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,5 +10,6 @@\n \n The `Chunk` model represents a collection of segments. It consists of:\n \n ```json\n+\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727386701399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,8 +10,9 @@\n \n The `Chunk` model represents a collection of segments. It consists of:\n \n ```json\n-\n-```\n-```json\n+{\n+    \"segments\": Vec<Segment>,\n+    \"chunk_length\": i32,\n+}\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727386726943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,7 +12,7 @@\n \n ```json\n {\n     \"segments\": Vec<Segment>,\n-    \"chunk_length\": i32,\n+    \"chunk_length\": \"<number>\",\n }\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727386740706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,8 @@\n The `Chunk` model represents a collection of segments. It consists of:\n \n ```json\n {\n-    \"segments\": Vec<Segment>,\n+    \"segments\": \"<Segment[]>\",\n     \"chunk_length\": \"<number>\",\n }\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727386751932,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,8 @@\n The `Chunk` model represents a collection of segments. It consists of:\n \n ```json\n {\n-    \"segments\": \"<Segment[]>\",\n-    \"chunk_length\": \"<number>\",\n+    \"segments\": \"Segment[]\",\n+    \"chunk_length\": \"123\",\n }\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1727386787937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,5 +14,13 @@\n {\n     \"segments\": \"Segment[]\",\n     \"chunk_length\": \"123\",\n }\n-```\n\\ No newline at end of file\n+```\n+\n+## Segments\n+\n+This will contain a list of segments that make up the chunk.\n+\n+## Chunk Length\n+\n+This will contain the length of the chunk in number of segments.\n"
                },
                {
                    "date": 1727386848889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,5 +22,12 @@\n This will contain a list of segments that make up the chunk.\n \n ## Chunk Length\n \n-This will contain the length of the chunk in number of segments.\n+This will contain the actual length of the chunk, which is the number of words in the chunk.\n+This may be different from the `target_chunk_length` because of the following reasons:\n+\n+- The `target_chunk_length` is a suggestion, not a strict requirement.\n+- Some segments may be too long to fit into the chunk, so they are split into multiple segments.\n+- Some segments may be too short to fit into the chunk, so they are combined with other segments.\n+\n+This is useful when you want to know the actual length of the chunk in words.\n"
                },
                {
                    "date": 1727386960767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,11 +23,6 @@\n \n ## Chunk Length\n \n This will contain the actual length of the chunk, which is the number of words in the chunk.\n-This may be different from the `target_chunk_length` because of the following reasons:\n-\n-- The `target_chunk_length` is a suggestion, not a strict requirement.\n-- Some segments may be too long to fit into the chunk, so they are split into multiple segments.\n-- Some segments may be too short to fit into the chunk, so they are combined with other segments.\n-\n-This is useful when you want to know the actual length of the chunk in words.\n+This may be different from the `target_chunk_length` as the `segments` are not split into smaller segments.\n+The actual length is the most amount of segments that can fit into the chunk, but not exceeding the `target_chunk_length`.\n"
                },
                {
                    "date": 1727387050709,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,11 +18,11 @@\n ```\n \n ## Segments\n \n-This will contain a list of segments that make up the chunk.\n+This will contain an array of segments that make up the chunk.\n \n ## Chunk Length\n \n-This will contain the actual length of the chunk, which is the number of words in the chunk.\n+This will contain the actual length of the chunk, i.e. number of words in the chunk.\n This may be different from the `target_chunk_length` as the `segments` are not split into smaller segments.\n The actual length is the most amount of segments that can fit into the chunk, but not exceeding the `target_chunk_length`.\n"
                },
                {
                    "date": 1727387062001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,6 +23,6 @@\n \n ## Chunk Length\n \n This will contain the actual length of the chunk, i.e. number of words in the chunk.\n-This may be different from the `target_chunk_length` as the `segments` are not split into smaller segments.\n+This may be different from the `target_chunk_length` as the segments are not split into smaller segments.\n The actual length is the most amount of segments that can fit into the chunk, but not exceeding the `target_chunk_length`.\n"
                },
                {
                    "date": 1727387078985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,5 +24,4 @@\n ## Chunk Length\n \n This will contain the actual length of the chunk, i.e. number of words in the chunk.\n This may be different from the `target_chunk_length` as the segments are not split into smaller segments.\n-The actual length is the most amount of segments that can fit into the chunk, but not exceeding the `target_chunk_length`.\n"
                },
                {
                    "date": 1727387121046,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,12 +9,12 @@\n ## Chunk Model\n \n The `Chunk` model represents a collection of segments. It consists of:\n \n-```json\n-{\n-    \"segments\": \"Segment[]\",\n-    \"chunk_length\": \"123\",\n+```typescript\n+interface Chunk {\n+    segments: Segment[];\n+    chunk_length: number;\n }\n ```\n \n ## Segments\n"
                }
            ],
            "date": 1727386436235,
            "name": "Commit-0",
            "content": "---\ntitle: Chunks\n---\nThe ChunkMyDocs API processes documents by analyzing their layout and segmenting them into meaningful chunks suitable for Retrieval-Augmented Generation (RAG) and Large Language Models (LLMs). \n\n![Model Diagram](sample2.png)\n\n## Segments vs. Chunks\n\n- **Segments**: These are the fundamental building blocks extracted from the document. Each segment represents a specific part of the document, such as a title, section header, paragraph, list item, table, picture, caption, formula, footnote, page header, or footer. Segments are identified using unique identifiers, precise bounding boxes, and their content type.\n\n- **Chunks**: Chunks are collections of one or more segments. They serve as higher-level groupings that can be used for various downstream applications like indexing, searching, or further analysis. The grouping of segments into chunks depends on the `target_chunk_length` parameter:\n\n  - **No Chunking (`target_chunk_length = 0`)**: Each segment is treated as an individual chunk, maintaining a one-to-one relationship and preserving the original document structure without additional grouping.\n\n  - **With Chunking (`target_chunk_length > 0`)**: Segments are grouped into chunks up to the defined length, excluding headers and footers to maintain content integrity. For example, with `target_chunk_length = 512`, each chunk can contain up to 512 words.\n\n## Segment and Chunk Models\n\n### Segment Model\n\nThe `Segment` model represents individual elements extracted from the document. It includes the following properties:\n\n- `segment_id`: Unique identifier for the segment.\n- `bbox`: Bounding box defining the segment's position on the page.\n- `page_number`: Integer specifying the page number.\n- `page_width`, `page_height`: Dimensions of the page.\n- `content`: Text content of the segment.\n- `segment_type`: Type of the segment (e.g., Title, Text, Table).\n- `ocr`: Optional OCR results associated with the segment.\n- `image`, `html`, `markdown`: Optional representations of the segment's content.\n\n### Chunk Model\n\nThe `Chunk` model represents a collection of segments. It consists of:\n\n- `segments`: An array of `Segment` objects.\n- `chunk_length`: Integer specifying the length of the chunk in words.\n\nFor detailed schema information, please refer to the API documentation.\n\n## Bounding Boxes and DPI\n\nAccurate annotation of segments relies on precise bounding boxes, which are determined based on the document's DPI (Dots Per Inch). DPI affects the scaling and positioning of elements within the document:\n\n- **Bounding Boxes**: Each segment has a bounding box defined by its top-left and bottom-right coordinates. These coordinates locate the segment within the page, ensuring that annotations and further processing align correctly with the original document layout.\n\n- **DPI Considerations**: The DPI setting influences how bounding boxes are calculated. By default, all incoming files are scaled to 150 DPI, and bounding box coordinates are based on this scaling to maintain consistency.\n\n## Annotating Segments and Chunks\n\nAnnotation involves visually highlighting segments within the document to provide clarity and facilitate further analysis. The `annotate.py` script is responsible for drawing bounding boxes around segments:\n\n```python\nimport fitz  # PyMuPDF\nfrom models import TaskResponse\nimport json\n\ndef draw_bounding_boxes(pdf_path: str, output_data: TaskResponse, output_path: str):\n    color_map = {\n        \"Caption\": (1, 0, 0),\n        \"Footnote\": (0, 1, 0),\n        \"Formula\": (0, 0, 1),\n        \"ListItem\": (1, 1, 0),\n        \"PageFooter\": (1, 0.5, 0),\n        \"PageHeader\": (0.5, 0, 0.5),\n        \"Picture\": (1, 0.75, 0.8),\n        \"SectionHeader\": (0.6, 0.3, 0),\n        \"Table\": (0.54, 0, 0),\n        \"Text\": (0, 0, 0),\n        \"Title\": (1, 0, 0)\n    }\n\n    pdf_document = fitz.open(pdf_path)\n\n    for chunk in output_data.chunks or []:\n        for seg in chunk.segments:\n            page = pdf_document[seg.page_number - 1]\n            rect = fitz.Rect(\n                seg.bbox.top_left[0],\n                seg.bbox.top_left[1],\n                seg.bbox.bottom_right[0],\n                seg.bbox.bottom_right[1]\n            )\n            color = color_map.get(seg.segment_type, (0, 0, 0))\n            page.draw_rect(rect, color=color, width=1)\n\n    pdf_document.save(output_path)\n    pdf_document.close()\n```\n\n### How It Works\n\n1. **Color Mapping**: Each segment type is assigned a specific color for easy differentiation during annotation.\n2. **Processing Segments**: The script iterates through all chunks and their respective segments, drawing rectangles around each segment based on their bounding box coordinates.\n\nBy understanding and utilizing segments and chunks effectively, along with accurate bounding box annotations, you can leverage the ChunkMyDocs API to its full potential, enabling robust document analysis and processing workflows.\n\n```\n\n```\n\n\n![Model Diagram](sample2.png)\n"
        }
    ]
}