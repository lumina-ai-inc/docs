---
title: Output
description: Understanding data returned by the Parse feature.
---

import { Frame, CodeGroup, Note, Card, CardGroup } from "@mintlify/components";

## High-Level Structure

<Frame>
```mermaid
graph TD;
    Task["<b>Task</b><br/>(task_id, status, ...)"] --> Output["<b>Output Object</b>"];
    
    
        Output --> Metadata["<b>Metadata</b><br/>- file_name<br/>- mime_type<br/>- page_count<br/>- pdf_url"];
        Output --> Chunks["<b>chunks</b> [ ]"];
        Output --> Pages["<b>pages</b> [ ]"];

    Chunks --> Chunk["<b>Chunk</b><br/>- chunk_id<br/>- chunk_length<br/>- embed<br/>- segments[]"];
    Chunk --> Segment["<b>Segment</b><br/>- content<br/>- description<br/>- bbox<br/>- ss_* fields"<br/>...];

    Pages --> Page["<b>Page</b><br/>- page_number<br/>- image<br/>- pg_width, pg_height<br/>- dpi<br/>- ss_sheet_name"];

````
</Frame>

<b>Parse</b> returns a `Task` object. When processing is successful, the `output` field contains the structured representation of your document. The core of this output is a list of `chunks`, which are composed of individual `segments`.

<CodeGroup>
```json Top-Level Output
{
  "task_id": "8b7e7e8a-...",
  "status": "Succeeded",
  "output": {
    "file_name": "document.pdf",
    "page_count": 2,
    "chunks": [
      // ... array of chunk objects
    ],
    "pages": [
      // ... array of page objects with full-page images
    ]
  },
  // ... other task metadata
}
````

</CodeGroup>

### Chunks and Segments

The document is first broken down into `segments`, which represent individual semantic elements like a paragraph, table, or title. These segments are then grouped into `chunks` based on your chunking configuration.

- **Segments**: The smallest building blocks. Each segment corresponds to a single, identified element from the source document.
- **Chunks**: A logical grouping of one or more segments. Each chunk includes `chunk_length`, `content`, `embed`, and `segments[]`. For RAG applications, chunks are the units of information that are typically embedded and retrieved.

The supported segment types are: `Caption`, `Footnote`, `Formula`, `ListItem`, `Page`, `PageFooter`, `PageHeader`, `Picture`, `SectionHeader`, `Table`, `Text`, and `Title`.

<Note>By default, headers and footers are ignored. To change this behaviour you can [adjust your configuration](/docs/advanced/parse/configuration#segment-level-customization-segment-processing).</Note>

---

## Key Output Fields

Each `segment` object contains rich information. At the `chunk` level, corresponding fields are concatenated from all of the segments within that chunk. Here are the most important fields:

### 1. `content`

The `content` field holds the primary, structured representation of the segment. Each segment is formatted based on it's type.

- **Tables**: Converted to HTML to maintain complex col/row-span structure.
- **Images**: Converted to a robust markdown description, with charts/graphs including a tabular representation.
- **Formulas**: Converted to LaTeX strings for perfect mathematical representation. They can even be embedded within an HTML table if a formula appears inside a cell.
- **Text-type**: Text-heavy segments like title, section headers and text blocks are converted into markdown.

<CodeGroup>
```json Segment with HTML Table and LaTeX
{
  "segment_type": "Table",
  "content": "<table><tr><td>The formula is:</td><td>\\( E=mc^2 \\)</td></tr></table>"
}
```
</CodeGroup>

### 2. `embed`

The `embed` field provides the clean, RAG-optimized text that should be used for generating embeddings.

- It includes the `content` and, if present, the `description`. This helps optimize the table segments without contaminating the content field.
- This is the field used for calculating token counts when chunking, ensuring chunks fit your target length.

<CodeGroup>
```json Chunk with embed field
{
  "chunk_id": "chunk-1-...",
  "chunk_length": 45,
  "embed": "The table shows a 15% increase in Q2 revenue for Widget A... | Product | Q1 | Q2 | ...",
  "segments": [ /* ... */ ]
}
```
</CodeGroup>

### 3. `bbox` (Bounding Box)

Every segment includes a precise bounding box (`bbox`) that pinpoints its exact location on the original page. This is essential for building applications that require citations or highlighting.

- The coordinates (`left`, `top`, `width`, `height`) are scaled relative to the `page_width` and `page_height` of the page the segment belongs to.
- The `dpi` field in the `pages` array indicates the resolution a page image was rendered at, allowing you to accurately map the `bbox` to a rendered image.

<CodeGroup>
```json Segment with Bounding Box
{
  "segment_type": "Text",
  "bbox": { "left": 100, "top": 250, "width": 500, "height": 50 },
  "page_number": 1,
  "page_width": 792,
  "page_height": 612
}
```
</CodeGroup>

---

## Spreadsheet-Specific Outputs (`ss_*`)

<Frame caption="A financial spreadsheet showing intelligent segmentation of tables and charts.">
  <img src="https://mintlify.s3.us-west-1.amazonaws.com/lumina-53fcea44/assets/excel_parsing_example.png" />
</Frame>

When processing spreadsheet files (`.xlsx`, `.xls`), the output includes additional `ss_*` prefixed fields that provide native Excel context. These fields exist alongside the standard `content`, `embed`, and `bbox` fields, enriching each segment with its precise location and native data from the original spreadsheet.

### Key Fields

- **`ss_range`**: The cell range for the segment in A1 notation (e.g., `A1:D10`).
- **`ss_cells`**: A detailed array of each cell in the segment, including its original formula, value, text and styling. Allows you to see both the raw formula (`=SUM(B2:B10)`) and its calculated result (`$55,000`).
- **`ss_header_*`**: Fields identifying the detected header for a table (`ss_header_range`, `ss_header_text`). Headers are intelligently associated even if they are not directly adjacent to the table.

These spreadsheet-native values unlock powerful capabilities:

- **Create Interactive Experiences**: Use `ss_range` to build native citation experiences that let users click data and jump to the precise source cell in a viewer.

- **Get Cleaner LLM Context**: Combine layout analysis with precise cell data to identify tables, associate headers, and filter out irrelevant cells. This provides cleaner, more meaningful context for LLM processing.

- **Build Powerful Spreadsheet Agents**: Use the `ss_*` fields to build AI agents that can read, analyze, and even **write** back to spreadsheets. Understanding cell formulas and values enables agents to automate tasks like updating financial models, correcting entries, or adding new rows.

---

<Tip>Looking for additional output fields? See the Advanced Outputs section below for more metadata options.</Tip>

<Accordion title="Advanced Outputs">

Beyond the key fields discussed above, the Parse output is enriched with a variety of other useful metadata at the file, page, and segment levels. Here are some of the most valuable advanced fields:

- **Word-Level Bounding Boxes**: Included in the `ocr` array for each page, this provides the precise coordinates for every single word detected by the OCR process. This is ideal for building applications that require highlighting specific words or phrases in a document viewer.

- **Cropped Segment Images**: Each segment object contains an `image` field with a URL to a cropped image of just that segment. This is incredibly useful for providing visual context to an LLM or displaying the source of a specific chunk of text.

- **File & Page Metadata**: The top-level `output` object contains file-level metadata like the original `file_name`, `mime_type`, and `page_count`. Additionally, the `pages` array contains detailed information for each page, including a full-page image URL, dimensions (`pg_width`, `pg_height`), and DPI.

For a comprehensive breakdown of every field available in the output, please refer to our [API Reference](/api-references).

</Accordion>
